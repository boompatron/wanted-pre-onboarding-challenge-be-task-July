DB의 같은 row를 수정할 때, 동시성 문제가 발생할 경우 해결방법은 크게 두 가지라고 생각합니다.

1. DB locking을 통한 다른 트랜잭션의 접근을 제어함
2. 분산락을 통한 글로벌 locking을 통한 동시성 제어

가장 먼저 떠올릴 수 있는 방법은 1번 db lock이라 생각합니다.
공유락, 배타락을 통해 임계 영역에 접근하려는 다른 트랜잭션을 아예 원천 차단하는 식의 방식으로 다른 트랜잭션의 접근을 차단해서 db의 일관성을 지킬 수 있습니다.

JPA를 사용하면 낙관적 락을 사용해서 어플리케이션 수준에서도 동시성을 제어할 수 있으며, 비관적 락을 사용할 경우 db 락과 마찬가지로 다른 트랜잭션의 접근을 원천 차단해 문제를 해결할 수 있습니다.

하지만 낙관적 락의 경우 트랜잭션의 충돌이 잦을 경우 예외 처리 로직이 계속 호출되어 오히려 성능 저하가 일어날 수 있습니다.
또한 비관적 락을 경우에는 애초에 한 트랜잭션이 점유를 할 경우 다른 트랜잭션의 접근이 차단되기 때문에 요청의 처리 시간이 필연적으로 길어질 수 밖에 없습니다.


그렇다면 단순이 자바 기준 synchronized 키워드를 사용해서 여러 쓰레드의 race condition 상황 발생시 동기화를 시켜줄 수 있지 않느냐? 
라고 생각할 수 있지만

서비스 운영 단계의 경우 여러 서버를 운영하기 때문에 하나의 서버 안에서는 정합성이 보장될 수 있겠으나, 서로 다른 서버 끼리의 정합성을 보장할 수 없으므로, 좋은 방법은 아닙니다.

그렇기 때문에 분산락을 통해서 동시성을 제어하는 방법이 필요하다고 생각합니다.
대표적으로 Redis 와 같은 외부 라이브러리를 통해 해당 문제를 해결할 수 있습니다.

Redis의 경우 속도가 매우 빠르기 때문에 글로벌 캐시로서도 작용하는데 좋습니다.
그리고 내부적으로는 싱글쓰레드로 동작하기 때문에 위와 같은 race condition이 발생할 때, 문제를 해결하는데 사용하기에 좋습니다.

여러 서버에서 동시에 같은 row를 수정하려고 요청이 들어와도, 레디스의 싱글 쓰레드를 거치면 한줄로 서서 순서를 기다리게 되니까요.

저는 위와 같은 이유들로 DB Locking, 분산락을 사용하면 문제싀 상황을 해결할 수 있을 것 같습니다.
