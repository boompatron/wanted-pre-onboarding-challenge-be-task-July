자바의 ArrayList 가 내부적으로 동작하는 방식을 설명해 보겠습니다.

ArrayList의 경우 동적으로 길이 조정이 가능한 array입니다.
내부적으로는 array로 구현이 되어 있지만, 동적으로 길이가 변하는 점이 기존의 길이가 고정된 배열과는 다른 점입니다.
이는 linkedlist와 같은 접입니다.
하지만 내부적으로는 array로 구현이 되어 있기 때문에 각각의 index를 통해서 random access가 가능하기 때문에 linkedlist 보다는 특정 인덱스로의 이동이 빠릅니다.
하지만 array로 구현되어있다는 특징 때문에 데이터를 중간에 삽입하거나 삭제할 경우, 해당 인덱스의 데이터보다 뒤에 있는 데이터들의 위치를 모두 변경시켜야 하기 때문에(앞으로 이동), 시간은 Linkedlist에 비해 오래 걸립니다.

그리고 collection을 구현하고 있기 때문에 자바의 collection에서 데이터를 순회하거나 상태를 조회하는 isEmpty, hasNext와 같은 메소드들을 모두 사용할 수 있습니다.


또한 프로그래밍언어에서 array 와 linkedlist의 차이점을 정리해 보겠습니다.
- 배열
  - 컴파일시 배열의 길이가 정해짐 -> 동적으로 수정할 수 없음, 배열의 길이보다 큰 데이터를 넣으려고 시도하거나 올바르지 않은 인덱스로 접근을 시도하면 에러가 발생함
  - 논리적인 데이터의 위치와 물리적인 데이터 저장 위치가 동일함.
  - 인덱스로 접근할 경우 O(1)의 시간 복잡도로 바로 접근이 가능함(매우 빠름), 인덱스를 모를 경우에는 반복문을 통해서 배열을 순회하면서 찾고자 하는 데이터와 일치하는 데이터를 찾아야 함
  - 데이터를 추가하거나 삭제할 경우에는 시간이 다소 걸림. 중간에 있는 데이터를 삭제하거나 중간에 데이터를 추가할 경우, 해당 데이터보다 뒤에 있는 데이터를 전부 뒤로 밀거나(추가했을 경우), 앞으로 당겨야 하기 때문에(삭제의 경우) 최대 O(n)의 시간복잡도가 걸림

- LinkedList
  - 총 길이는 동적으로 늘어나거나 줄어들 수 있음. Heap 영역에서 관리되기 때문에 동적으로 길이 조정이 가능함
  - 논리적인 데이터의 위치와 물리적인 데이터의 위치가 상관이 없음.
  - 특정 인덱스로 접근할경우 -> linkedlist의 데이터를 각각 노드라고 불리는데, 각 노드는 자신의 다음 데이터만 알고 있거나(Singly linkedlist), 자신의 앞 뒤 데이터만 알고 있음(doubly linkedlist) 그렇기 때문에 사용자가 찾고자 하는 노드가 나올 때 까지 head(또는 tail)에서 하나 하나 노드들을 거치면서 찾는 방법밖에 없음. 최대 O(n)의 시간 복잡도가 걸림
  - 특정 위치에 데이터를 삽입하거나 삭제를 할 경우에는 배열보다는 유리함. 데이터들의 물리적인 위치와 논리적인 위치는 상관이 없기 때문에 특정 위치에 데이터를 삽입할 경우에는 그냥 그 그전에 존재하던 데이터 간의 링크를 끊은 다음 데이터를 넣고 다시 적절하게 연결시켜 주면 되고, 삭제할 경우에도 삭제하고자 하는 데이터를 삭제한 다음, 링크를 끊기만 하면 되기 때문에 속도가 비교적 빠름
